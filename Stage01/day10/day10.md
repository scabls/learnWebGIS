## JS概念及入门

### 概念

​	一种运行客户端的脚本语言（也可以运行在服务器端：后面讲的node.js）

### 特点

​	不同于其他编程语言（C语言，Java），JavaScript是解释执行（读一行、执行一行）

### 作用

​	动态读取页面元素的样式
​	表单校验
​	页面特效（轮播图）
​	控制页面元素（DOM操作）电灯开关案例，改变页面文本的颜色等样式
​	事件处理（监听按钮的点击）
​	服务器端开发（node.js实现后端开发）

### 组成

​	ECMAScript 基础语法（数据类型，变量，运算符，流程控制，面向对象，内置对象）

​	DOM	文档对象模型（实现对HTML文档的操作，动态的添加删除修改元素的属性和内容）

​	BOM	浏览器对象模型（实现弹框、窗口关闭打开、定时器效果、页面跳转）

### 入门

#### 1.内嵌式引入

在html文件中使用script标签，写入内嵌代码

#### 2.外链式引入

新建一个js文件，把js代码放进去，然后在页面使用script标签的src属性引入

好处：可以在多个页面引入

注意：如果script标签既有外链文件，又有内嵌代码，只会执行外链文件

​	如果当前页面还需要编写JS代码,可以再开一个script标签,这些标签最终都在一个环境中

注意：只要在标签上写了src属性，即使无值或值为空也会被视为外链式引入

#### 3.注释

单行注释 ctrl+/

// 单行注释 ctrl+/

多行注释 ctrl+shift+/

/* 多行注释 ctrl+shift+/ */

​	多行注释只能嵌套单行注释不能嵌套多行注释

#### 4.输入输出

输出

​    // 输出方式一：弹框

​    alert("Hello World!");

​    // 输出方式二：打印到控制台

​    console.log("Hello World!")

​    // 输出方式三：输出到页面

​    document.write("Hello World!");

输入

​    // 输入方式：通过弹窗录入

​    prompt("请输入您的姓名：", "张三")

​    var age = prompt("请输入您的年龄：", "25");

​    alert("您的年龄是：" + age)

## 变量

### 概念

本质是内存中存储数据的空间

### **作用**

存储变化的数据

### 使用

#### 声明变量

##### 方式一：先声明，后赋值

```js
var age; //变量声明之后，该变量是空的（它没有值）。
age = 10; //如需向变量赋值，请使用等号
```

##### 方式二：声明的同时赋值

```js
var age = 18;
```

一个好的编程习惯是，在代码开始处，统一对需要的变量进行声明。

#### 一条语句，多个变量

您可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可：

```js
var lastname="Doe", age=30, job="carpenter";
```

声明也可横跨多行：

```js
var lastname="Doe",
age=30,
job="carpenter";
```

一条语句中声明的多个变量不会同时赋同一个值:

```js
var x,y,z=1;
```

x,y 为 undefined， z 为 1。这是因为X和y只声明了但没有赋值。

##### Value = undefined

声明时未赋值的变量值其实是undefined

#### 重新声明 JavaScript 变量

如果重新声明 JavaScript 变量，该变量的值不会丢失：

在以下两条语句执行后，变量 carname 的值依然是 "Volvo"：

```js
var carname="Volvo";
var carname;
```

#### 使用 let 和 const (ES6)

[JavaScript let 和 const](https://www.runoob.com/js/js-let-const.html)

### 变量名注意点

变量必须以字母开头

变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）

变量名称对大小写敏感（y 和 Y 是不同的变量）

不能是关键字或保留字

​	也应该避免使用JavaScript内置的对象、属性和方法的名称作为JavaScript的变量或函数名

尽量见名知意

### 命名规范

*小驼峰命名法*

首字母小写后面每个单词首字母大写

var bigAppleTree

一般作为变量名 函数名 对象名 方法名

*大驼峰命名法*

每个单词首字母大写

SmallStar

一般作为类名 构造函数名 vue组件名

*全都是大写*

一般用作常量

PI 

MAX-WIDTH（设置一个固定的最大宽度）

## 数据类型

### 概念

给数据分类，方便管理

### 分类

#### 值类型(基本类型)

字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。

| 简单数据类型 | 说明                                                         | 默认值     |
| ------------ | ------------------------------------------------------------ | ---------- |
| Number       | 数字型, 包含整型和小数型, 如21, 0.2333。这里注意一种特殊的数: NaN(Not a Number)非数 | 0          |
| String       | 字符型, 如'张三', 字符串带引号。单引号, 双引号都可以, 推荐使用单引号, HTML中一般使用双引号。引号成对使用 | ''(空字符) |
| Boolean      | 布尔型, 如true, false; 等价于1和0                            | false      |
| Undefined    | 未定义, 变量声明, 未赋值就是undefined                        | undefined  |
| Null         | 空，主要是给对象类型赋值                                     | null       |

#### 引用数据类型（对象类型）

对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）

#### 声明变量类型

当您声明新变量时，可以使用关键词 "new" 来声明其类型：

```js
var carname=new String; //string
var x=      new Number; //number
var y=      new Boolean; //boolean
var cars=   new Array; //object
var person= new Object; //object
```

JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。

#### undefined 和 null 的区别

null 和 undefined 的值相等，但类型不等：

```js
typeof undefined             // undefined
typeof null                  // object（应该是null）
null === undefined           // false
null == undefined            // true
```

### 动态类型

JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型：

```js
var x;        // x 为 undefined
var x = 5;      // 现在 x 为数字
var x = "John";   // 现在 x 为字符串
```

变量的数据类型可以使用 **typeof** 操作符来查看：

```js
typeof "John"         // 返回 string
typeof 3.14          // 返回 number
typeof false         // 返回 boolean
typeof [1,2,3,4]       // 返回 object
typeof {name:'John', age:34} // 返回 object
```

### 类型转换

#### 强制转换

又称为显式转换（能够看到的转换），其实是调用了一些方法

**应用场景**

prompt返回的值是字符串类型,即使我们输入数字。这时候进行输入数字的加法，其实是字符串的拼接。要将字符串转为数字类型在进行加法运算。

```javascript
String()    将数据转成字符串
Number()    将数据转成数字
	null可以被Number转成0,undefined不行，转出来的是NaN
Boolean()   将数据转成布尔类型
```

##### 将数据转成字符串

```js
// String()    将数据转成字符串
    var age = String(25);
    console.log(age, typeof age);// "25" string
    var a = String(true);
    console.log(a, typeof a);// "true" string
    var b = String(null);
    console.log(b, typeof b);// "null" string
```

##### 将数据转成数字

```js
// Number()    将数据转成数字
    var c = Number(100);
    console.log(c, typeof c);// 100 number
    var d = Number(true);
    console.log(d, typeof d);// 1 number
    var e = Number(false);
    console.log(e, typeof e);// 0 number
    var f = Number(undefined);
    console.log(f, typeof f);//NaN(not a number) number
    var g = Number(null);
    console.log(g, typeof g);// 0 number
    var h = Number('h');
    console.log(h, typeof h);//NaN number
```

###### 将字符串转换为数字

全局方法 **Number()** 可以将字符串转换为数字。

字符串包含数字(如 "3.14") 转换为数字 (如 3.14).

空字符串转换为 0，空格字符串也会转换为0

其他的字符串会转换为 NaN (不是个数字)。

```js
Number("3.14")    // 返回 3.14
Number(" ")       // 返回 0
Number("")        // 返回 0
Number("99 88")   // 返回 NaN
```

| 方法         | 描述                               |
| :----------- | :--------------------------------- |
| parseFloat() | 解析一个字符串，并返回一个浮点数。 |
| parseInt()   | 解析一个字符串，并返回一个整数。   |

```js
/* 
parseInt()和Number()区别
相同点
	都可以将数字类型的字符串转成数字
不同点
    parseInt可以逐个解析，直到遇到非数字的字符才会停止
    Number不会逐个解析，只要有非数字的字符直接显示NaN
*/
console.log(parseInt("123.456")); // 123
console.log(Number("123.456a")); // NaN
```

###### 一元运算符 +

 **+** 可用于将变量转换为数字

```js
var y = "5";      // y 是一个字符串
var x = + y;      // x 是一个数字
```

如果变量不能转换，它仍然会是一个数字，但值为 NaN (not a number)

```js
var y = "John";   // y 是一个字符串
var x = + y;      // x 是一个数字 (NaN)
```

##### 将数据转成布尔类型

```js
// Boolean()   将数据转成布尔类型
    var i = Boolean('false')//false带引号就不再是关键字false了，变成了字符串
    console.log(i, typeof i);//true boolean
    var j = Boolean(0);
    console.log(j, typeof j);//false boolean
    var k = Boolean(1);
    console.log(k, typeof k);//true boolean
    var l = Boolean(null);
    console.log(l, typeof l);//false boolean
    var m = Boolean(undefined);
    console.log(m, typeof m);//false boolean
    var n = Boolean("");//空字符串
    console.log(n, typeof n);//false boolean
    var o = Boolean(" ");//空格字符
    console.log(o, typeof o);//true boolean
        // 应用场景
        if ("hhh") {//隐含了一个Boolean的转换
            console.log("aaaaaa");
        }
// 注意空格字符转换成数字是0，但是转换成布尔值却是true
```

#### 自动转换

隐式转换（转换的过程是看不到的，但是它的内部确实做了转换）

当 JavaScript 尝试操作一个 "错误" 的数据类型时，会自动转换为 "正确" 的数据类型。

在运算中进行隐式转换，输出”正确的“数据类型的结果，但**并不改变原数据的数据类型**

```js
5 + null    // 返回 5         null 运算时转换为 0 
"5" + null  // 返回"5null"   null 运算时转换为 "null"
"5" + 1     // 返回 "51"      1 运算时转换为 "1" 
"5" - 1     // 返回 4         "5" 运算时转换为 5
```

```js
var a = null;
var b = true;
alert(a + '-' + b + '=' + (a - b) + " a的类型为："+typeof a  + " b的类型为："+typeof b+ " a-b的类型为："+typeof (a - b));
```

##### 特点

字符串+任意类型数据，执行的就是字符串的拼接

+之外的其余算术运算符：-、*、/、%等在运算时将所有数据类型都转换为数字，输出数字类型的结果

true、false、null跟数字运算的时候，都会被转为数值

##### 对于+运算的规律

如果有字符串参与运算，则会自动转换为字符串的拼接

如果没有字符串参与，默认使用Number()函数进行转换，再进行运算

### 模板字符串

```
JavaScript 中的模板字符串是一种方便的字符串语法，允许你在字符串中嵌入表达式和变量。
        模板字符串使用反引号 `` 作为字符串的定界符分隔的字面量。
        模板字面量是用反引号（`）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和一种叫带标签的模板的特殊结构。
        字符串插入变量和表达式：变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。
```

## 运算符

### 算术运算符

算数运算符就是数学运算中的`加减乘除`

| 运算符 | 描述 | 实例                            |
| ------ | ---- | ------------------------------- |
| +      | 加   | 20 + 10 = 30                    |
| -      | 减   | 20 - 10 = 10                    |
| *      | 乘   | 20 * 10 = 200                   |
| /      | 除   | 10 / 20 = 0.5                   |
| %      | 取模 | 返回余数18 % 2 = 0 ; 15 % 2 = 1 |

#### 提取数字每个单位上的值

##### 场景

弹框输入一个三位数,求每一位上的数的和

要求用户输入秒数，并将其转换为时 分 秒的格式

##### 分析

将低级单名数根据进率转化为与高级单名数组合形式的名数

> **进率**：一个数，分别配上同类的两个计量单位，用高级单位表示出的数量和用低级单位表示出的数量之比，叫做这两个单位间的进率。
>
> 在对同一数量进行单位名称的改写时，就要用到进率。
>
> 高级单名数的数×进率=低级单名数的数
>
> 低级单名数的数÷进率=高级单名数的数
>
> **单名数**：带有一个单位名称的名数

##### 流程

**思路一**：先求商，再取整，最后求余

求商：使用基本单名数的数除以目标单位与基本单位间的进率，得到目标单名数的数。

取整：目标单名数的小数部分，表示不足一目标单名数的数量，这部分不需要进行单位转换。取整去掉小数部分。

求余：使用目标单位与高级单位间的进率对目标单名数的数求余，得到不足以向高级单位进行单位转换的目标单名数的数。

注：求解基本单名数时，因为目标单位和基本单位相同，前两步可省略。求解最高级单名数时没有更高级单位，所以不需要求余。

**思路二**：先求余，再求商，最后取整

求余：使用目标单位的高级单位与基本单位间的进率对基本单名数的数求余，得到不足以向高级单位转换的基本单名数

求商：得到的基本单名数除以目标单位与基本单位间的进率，得到目标单名数的数

取整：目标单名数的小数部分，表示不足一目标单名数的数量，这部分不需要进行单位转换。取整去掉小数部分。

注：求解基本单名数时，因为目标单位和基本单位相同，后两步可省略。求解最高级单名数时没有更高级单位，所以不需要求余，直接进行后两步。

###### 流程差别

方式一：先求商，再取整，最后求余

方式二：先求余，再求商、最后取整

关键差别主要在求商和求余的顺序，其实是思路的不同。

比如现在有许多积木和许多不同尺寸的箱子。

方式一就是拿箱子装这些积木，看能装满多少个箱子。然后用这些箱子把更大的箱子填满，看剩下多少个箱子。

方式二是先拿更大的箱子装积木，剩下无法装满大箱子的积木。再用箱子装剩下的积木，看能装满多少个箱子。

###### 求解方向

在实际计算中，从小到大或从大到小的方向都可以。但毕竟初始单位就是小单位，推荐从小到大并使用方式一。

###### 对于求整

当采用从小到大的思路计算时，也可以在计算前先减去所有低级单名数表示的数量，去掉不足一份当前单位的部分

#### 自增自减运算符

**自增自减**

​      在自身的基础上加1或者减1

**语法**

​      变量++ 或者 变量--  （只能写在**变量上**）   

```js
var num = 10

++num	// num的值已经自增为11，表达式返回10
num++ 	// num的值已经自增为12，表达式返回12

2++		//错误
```

**结论**

​      可以理解为只要有++就已经自增了, 变量的位置只决定参与运算时用的是自增前的还是自增后的。--同理

​      前提是这段代码被执行，如果没有被执行，自增自减不会生效。比如后面的逻辑短路问题，会导致被短路的代码不执行，也就不会自增自减。

#### 比较运算符

比较运算符是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果

| 运算符 | 说明                                             | 案例         | 返回值 |
| ------ | ------------------------------------------------ | ------------ | ------ |
| <      | 小于                                             | 1 < 2        | true   |
| >      | 大于                                             | 1 > 2        | false  |
| <=     | 小于等于                                         | 1 <= 2       | true   |
| `>=`   | 大于等于                                         | 1 >= 2       | false  |
| ==     | 等于(会隐式转换),仅判断值                        | '1' == true  | true   |
| !=     | 不等于                                           | NaN != NaN   | true   |
| ===    | 绝对等于, 判断类型和值                           | '1' === true | false  |
| !==    | 不绝对等于(值和类型有一个不相等，或两个都不相等) | '1' !== true | true   |

#### 逻辑运算符

逻辑运算符是用来进行布尔值运算的运算符

后面开发中经常用于多个**条件判断**

| 运算符 | 说明       | 案例         | 返回值 |
| ------ | ---------- | ------------ | ------ |
| &&     | 逻辑与 and | 2>1 && 3 >2  | true   |
| \|\|   | 逻辑或 or  | 2>1 \|\| 3>2 | true   |
| !      | 逻辑非 not | !true        | false  |

##### 逻辑与

全真为真, 一假为假

| 案例           | 返回值 |
| -------------- | ------ |
| true && true   | true   |
| false && true  | false  |
| true && false  | false  |
| false && false | false  |

##### 逻辑或

全假为假, 一真为真

| 案例             | 返回值 |
| ---------------- | ------ |
| true \|\| true   | true   |
| false \|\| true  | true   |
| true \|\| false  | true   |
| false \|\| false | false  |

##### 逻辑非

真假互换

| 案例   | 返回值 |
| ------ | ------ |
| !true  | false  |
| !false | true   |

##### 使用场景

```js
// 注意点
// 要求输入一个20与30之间的数
var num1= +prompt("请输入一个20与30之前的数：");
// alert(20<=num1<=30); 错误的，因为是两个条件，不能写成一个条件
alert(num1>=20 && num1<=30)
```

##### 短路运算

###### 逻辑与的短路问题

如果左边的表达式**不成立**（值为false），则右边的表达式**不再执行**

```js
var a = 3;
var b = 4;
console.log(a++ < 2 && b++ > 3); // false
console.log(a);	// 4
console.log(b); // 4
```

###### 逻辑或的短路问题

如果左边的表达式**成立**（值为true），则右边的表达式**不再执行**

```js
var c = 3;
var d = 4;
console.log(c++ > 2 || d++ < 3); // true
console.log(c); // 4
console.log(d); // 4
```

#### 赋值运算符

把数据赋值给变量的运算符

| 运算符             | 说明                                           | 案例                           |
| ------------------ | ---------------------------------------------- | ------------------------------ |
| =                  | 将右侧的值赋给左侧的变量                       | var a = 100                    |
| +=, -=，*=, /= ,%= | 将左侧变量与右侧的值进行运算后，再赋给左侧变量 | var b = 12; b %= 5 (b = b % 5) |

#### 运算符的优先级

| 优先级 | 运算符     | 顺序              |
| ------ | ---------- | ----------------- |
| 1      | 小括号     | ()                |
| 2      | 一元运算符 | ++ -- !           |
| 3      | 算数运算符 | 先 * / % 后 + -   |
| 4      | 关系运算符 | `>` `>=` `<` `<=` |
| 5      | 逻辑运算符 | 先 && 后 \|\|     |
| 6      | 赋值运算符 | =                 |

#### 三元/条件运算符

 一元运算符：一个元素参与的运算  +、++

二元运算符：两个元素参与的运算  +、-、*、/、%、==、!=、>、<、>=、<=

三元运算符：三个元素参与的运算  条件运算符 variablename=(condition)?value1:value2

```js
variablename=(condition)?value1:value2
/* 当条件为真，返回第一个值；条件为假，返回第二个值 */
```

##### 判断数字大小

```js
var a = 10;
var b = 90;
var c = 70;
var d = 100;
/* 先判断前两个值谁大，然后将较大值与第下一个值比较 */
var max= a > b? a:b;
max = max > c? max:c;
max = max > d? max:d;
/* 不推荐嵌套三元运算符 */
```

***复杂问题不要想着一步到位，而是将大问题拆解成小问题，有逻辑有条理地一步一步来***