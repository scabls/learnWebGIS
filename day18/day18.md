## 对象分类

### 全局对象

#### 全局环境

 浏览器中所有script标签其实都在一个环境中，这个环境叫做全局环境

#### 全局对象（Global Object）

加载页面时，js引擎会整合所有script标签的内容，产生一个对象，就是全局对象。在浏览器中指window对象

掌控着全局环境

#### 全局变量

全局环境下定义的变量

#### 全局函数

全局环境下定义的函数

#### 关系

全局变量作为全局对象（GO对象）的属性存在

全局函数作为全局对象（GO对象）的方法存在

### 活动对象

#### 活动对象（Active Object）

在函数被调用的时候产生的一个对象，用来保存当前函数内部的执行环境，也称为局部对象

管控的局部环境（函数里面的环境）

#### 局部变量

在函数里面定义的变量

#### 局部函数

在函数里面定义的函数

#### 关系

局部变量作为活动对象（AO对象）的属性存在

局部函数作为活动对象（AO对象）的方法存在

#### 特点

函数一旦调用完毕，就会被销毁。里面的环境和数据都会消失

## 预编译

### 全局预编译

#### 概念

在全局环境下（script标签里面），JS引擎对代码的预处理

#### 流程

1. 先查找全局变量的**声明**，作为GO对象的属性名，值是**undefined**
2. 再查找全局函数的**声明**，作为GO对象的方法名，值是**function**
3. 再从上往下依次执行代码，声明的语句会被略过（上面两步已经处理了声明）

**注意**：js的变量是动态类型

#### 总结

流程是先查变量后查函数，如果重名，肯定是函数覆盖变量，与它们在源码的位置无关。
但是执行代码时，赋值操作会把函数变成变量

### 函数预编译

#### 概念

在局部环境下（函数里面），JS引擎对代码的预处理

#### 流程

1. 在函数被调用的那一刻，为函数产生一个AO对象
2. 先查找**形参**和局部变量的**声明**，作为AO对象的属性名，值是**undefined**
3. 使用**实参**的值替换形参的值
4. 再查找局部函数的**声明**，作为AO对象的方法名，值是**function**
5. 再从上往下依次执行代码，声明的语句会被略过（前面已经处理了声明）

#### 总结

流程是先查变量后查函数，如果重名，肯定是函数覆盖变量，与它们在源码的位置无关。形参也会被函数覆盖。
但是执行代码时，赋值操作会把函数变成变量

## 作用域

#### 概念

就是一个区域，用于限定变量在某个范围内起作用

#### 好处

提高程序的可靠性

减少命名冲突（ES6语法：在同一个域中，不能定义相同的变量，否则会报错）

#### 分类

##### 全局作用域（在全局环境下）

由script标签产生的区域,从计算机的角度可以理解为window对象(GO对象)管控的区域

全局变量和全局函数都在全局作用域下,在页面关闭的时候被销毁

##### 局部作用域（在局部环境下）

由函数产生的区域,从计算机的角度可以理解为当前函数对象(AO对象)管控的区域

局部变量和局部函数都在局部作用域下,在函数执行完成之后被销毁

**注意**：若在局部作用域没有使用关键字声明变量，直接赋值，那么变量将属于全局变量，归属在全局作用域下

##### 块级作用域（在{}内）

是ES6语法,存在于if或者for循环语句的{}中,{}包含的区域就是块级作用域

```js
if(true){
    var a = 10 //ES5写法,定义的变量不受块级作用域的影响

    let b = 20 //ES6写法,定义的变量会受到块级作用域的影响,出了{}就无法使用
    }

console.log(a)
console.log(b) // b is not defined
```

## 作用域链

#### 概念

只要是代码，就会在一个域中。写在函数内部，只在局部作用域；没有写在函数内部的，就在全局作用域中。

如果作用域中含有函数，那么这个作用域内部就可以产生一个新的作用域，就形成了作用域链。

#### 作用

提供了一个查找机制，内部函数可以访问外部函数的变量。

使用链式查找来决定哪些数据能被内部函数访问。

访问,本质就是就近原则,一层层往上层作用域查找

#### 本质

就是一个数据结构(类似于数组类型),函数内部可以嵌套函数,每一次嵌套都会形成一个新的作用域

把这些作用域串起来,就形成了作用域链

*为闭包打基础*

## 原型

### 实例成员和静态成员

#### 实例成员

在构造函数中,通过this添加的成员,叫做实例成员

实例成员只能通过实例化对象(new 出来的对象)访问

```js
function Student(name,age){
    //实例属性
    this.name = name
    this.age = age
    //实例方法
    this.study = function(){
        console.log('学习')
    }
}

//创建两个学生对象
var stu1 = new Student('张三',23) //stu1就是实例化对象
console.log(stu1.name)  //访问实例属性通过实例化对象
stu1.study()            //调用方法也是通过实例化对象
```

#### 静态成员

在构造函数本身上添加的成员,叫做静态成员

静态成员只能通过构造函数访问

```js
function Student(){

}

//直接在构造函数上添加一个静态属性
Student.contry = '中国'

//直接在构造函数上添加一个静态方法
Student.exam = function(){
    console.log('考试')
}

//调用 --- 不需要创建对象,直接使用构造函数调用
var stu = new Student()
console.log(stu.contry)//undefined 因为它的静态属性和方法都是绑定在类上的,不在对象上

console.log(Student.contry)
Student.exam()

//静态的好处:非常的高效,无需创建对象,直接使用类名就可以调用(内置对象Math就是使用这种方式,非常适合工具类)
```

##### 好处

非常的高效,无需创建对象,直接使用类名就可以调用

可以将一些公共的东西(国籍,民族)放到静态成员中,可以减少内存分配

##### 类比

###### 饮水机和水杯

如果把饮水机定义成实例成员,就相当于每一个学生都有一台饮水机,会造成资源的浪费

如果把水杯定义成静态的,就相当于所有的学生都共用一个水杯,也不好,一般定义成实例的

### new关键字的弊端

每一次创建对象,就会为对象的方法,重新开辟一块空间,造成内存的浪费

```js
        function Student(name,age){
            this.name = name
            this.age = age
            this.study = function(){
                console.log('学习')
            }
        }
        var stu1 = new Student('张三',23) 
        var stu2 = new Student('李四',24)
        /* 
            创建对象时，new做了3件事
                1,在堆区中开辟了一块空间
                2,给空间中的属性和方法赋值(给方法赋值的时候,需要重新开辟空间,存储方法对应的匿名函数，再把地址赋给方法)
                3,返回空间中的首地址给对象名

            存在的问题
                每一次创建对象,就会为对象的方法,重新开辟一块空间,造成内存的浪费
        */

     //验证:传统new方式会不会为对象的方法重复开辟空间
     console.log(stu1.study === stu2.study)//false 说明不在同一个空间,其实就是为对象的属性和方法重复开辟空间

```

### 原型作用

#### 定义和用法

解决重复开辟方法空间的问题

不在构造函数里定义实例方法，而是使用类的prototype属性

```js
构造函数名.prototype.name=value
```

这样通过构造函数创建出来的对象都可以共享这些方法，从原型继承的方法的调用和实例方法调用方式一样。

注意，当继承的方法被调用时，this 值指向的是当前继承的对象，而不是拥有该方法的原型对象。

除了方法，原型也可以为对象新添加公共属性。

当访问对象的属性和方法时，若对象自己不具有这些属性和方法，就会寻找其原型是否具有，循着原型链一直寻找，若最终未找到，返回undefined。

#### 方法共享

通过原型可以让对象共享方法,避免了在每一个实例对象中为方法重复开辟空间,节省了内存

#### 扩展新功能

可以在不修改原有类的基础上,为它扩充新的属性和方法(给Array类扩展sum方法)

#### 实例

##### 共享方法

```js
function Student(name,age){
    this.name = name
    this.age = age
}

//类的prototype属性:不管什么类,里面都有这个属性,习惯称为类的原型,可以把一些公共的方法放到这里,对象都可以共享
console.dir(Array)
console.dir(Date)
console.dir(Student)

//做法:把公共的方法定义在原型上(类的prototype属性),将来创建对象的时候,就不会为对象的方法重复开辟空间
Student.prototype.study = function(){
    console.log('学习')
}
var stu1 = new Student('张三',23) 
var stu2 = new Student('李四',24)

//验证:传统new方式会不会为对象的方法重复开辟空间
console.log(stu1.study === stu2.study)//true 说明在同一个空间,没有重复开辟空间
```

##### 新增方法

```js
/* 
给js的Array类,扩展一个求数字类型数组的内部元素的和方法
sum() ->  [1,2,3,4] ==> 10
思路
	可以把sum方法定义在原型上面,将来所有Array对象都可以使用这个方法
*/

console.dir(Array)//发现数组大部分方法都是定义在原型中

Array.prototype.sum = function(){
    var res = this.reduce(function(total,num){
        // 在方法中，this 表示该方法所属的对象
        return  total + num
    },0)

    return res
}

//调用数组的sum方法
var arr = [1,2,3,4] 
console.log(arr.sum()) 
```



## 存储对象

#### 概念

Web 存储 API 提供了 sessionStorage （会话存储） 和 localStorage（本地存储）两个存储对象来对网页的数据进行添加、删除、修改、查询操作。

- localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。

- sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

#### 特点

数据都是存储在用户浏览器中

可以方便用户设置和读取数据，刷新页面也不会丢失数据

容量有限，sessionStorage约5M，localStorage约20M

只能存**字符串**，可以对js对象使用JSON.stringify()将其转换为json

#### 方法

```js
getItem(keyname)	返回指定键的值 //注意返回的是字符串
setItem(keyname, value)	添加键和值，如果对应的值存在，则更新该键对应的值。
removeItem(keyname)	移除键
clear()	清除存储对象中所有的键

Object.keys(localStorage) 获取本地存储中所有的键
Object.entries() 静态方法，返回一个二维数组，包含给定对象自有的可枚举字符串键属性的键值对
```

#### sessionStorage存储特点

1. 生命周期是关闭浏览器
2. 在同一个窗口(页面),可以共享数据(确保ip和端口一致)
3. 以键值对方式存储数据

####  localStorage存储特点

1. 生命周期是永久有效
2. 在多个窗口(页面),可以共享数据(确保ip和端口一致),仅限于同一个浏览器
3. 以键值对方式存储数据